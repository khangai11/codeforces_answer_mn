$a_i,b_i$-ийн байж болох хамгийн их утгыг $A$, бас $i$ бүрийн $b_i$-г $b'_i$ болговол бодлогын нөхцөлийг хангаад, мөн хамгийн бага үйлдэл хийдэг гэе. $b'_i \ge b_i$ байх ёстой. $i$ бүрийн хувьд $b'_i$-ийн байж болох $O(\log A)$ ялгаатай утгууд байна:

$a_0=a_n=0$ гэе. $a_i|a_{i+1}$-ийн 0 битүүдийг цагаан, 1 битүүдийг хар гэвэл хар битүүд дээр $b'_i$ заавал 1 байна. $a_{i-1}|a_i \ge b_i$ байвал $a_{i-1}|a_i=b'_i$ байх ёстой. Яагаад гэвэл цагаан битүүд дээр 0 байх нь үйлдлийн тоонд ч, мөн бодлогын нөхцөл хангахад ч аль алинд нь ашигтай.

$a_{i-1}|a_i<b_i$ байвал анх $v:=a_{i-1}|a_i$ гээд $j$-г цагаан битүүдээр ихээс нь бага руу гүйлгэхэд хэрэв
* $v|2^j<b_i$ бол $b'_i$-ийн $j$-р бит заавал 1 байх ёстой гээд $v:=v|2^j$. Яагаад гэвэл хэрэв $j$-р бит нь 0 бол дараагийн бүх цагаан битүүд 1 байсан ч $b_i$-ээс бага л байна.
* $v|2^j \ge b_i$ бол $b'_i$-ийн байж болох утгууд руу $v|2^j$-г нэмээд $v$-г хэвээр үлдээгээд цааш үргэлжлүүлнэ. Яагаад гэвэл $j$-р бит нь 1 болчих юм бол өмнөхтэй ижил шалтгаанаар дараагийн цагаан битүүд 0 байх нь ашигтай.

Ингэж $b'_i$-ийн байж болох утгуудыг олоод, тэдгээр нь $m_i$ ширхэг байдаг ба утгууд нь $c_{i,1},c_{i,2},...,c_{i,m_i}$ байдаг гэе. Тэгвэл $dp[i][j]= $ зөвхөн $1 \le k \le i$ байх $k$-уудын хувьд $b'_k$-уудыг $b'_i=c_{i,j}$ байхаар сонгоход хийх хамгийн бага үйлдлийн тоо $(1 \le i \le n,1 \le j \le m_i)$ гэсэн dp-ээр бодож болно. Шилжилтээ хийхдээ $$dp[i][j]=\min_{c_{i-1,k}\& c_{i,j}=a_{i-1}}dp[i-1][k]+c_{i,j}-b_i$$ 

**Time complexity: $O(n \log^2 A)$**\
[Submission](https://codeforces.com/contest/2119/submission/327665097)