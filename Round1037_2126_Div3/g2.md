$a_0=a_{n+1}=0$ гээд $L_i$-г $a_j<a_i$ ба $j<i$ байх хамгийн их $j$, $R_i$-г $a_j<a_i$ ба $j>i$ байх хамгийн бага $j$ гэе.\
$i$-ээр $1$-ээс $n$ хүртэл гүйгээд $min(a[l,r])=a_i$ байх үед хамгийн их $med(a[l,r])$-г олоход хангалттай. $L_i<l \le i \le r<R_i$ байх ба $med(a[l,r])$-ийн байж болох хамгийн их утгыг хоёртын хайлт хийж олъё.

$med(a[l,r]) \ge mid$ байж чадах эсэхийг шалгахдаа, ямар нэг $l,r$-ийн хувьд $l \le j \le r$ байх $j$-үүдийн хувьд $a_j \ge x$ бол 1-ээр, үгүй бол -1 ээр тооцоод нэмэхэд нийт нийлбэр сөрөг биш бол $med(a[l,r])\ge x$ байх тул энэ нийлбэрийн хамгийн их утгыг олоход хангалттай. Үүнийг $i$-ээс баруун, зүүн тийш нь гүйгээд $O(R_i-L_i)$ хугацаанд олж чадах боловч үүнийг бүх $i$-ийн хувьд хийвэл нийт $O(n^2)$ хугацаатай болно.\
Харин параллел хоёртын хайлт хийвэл $O(n\log^2{n})$ хугацаанд бодох боломжтой болно.

Паралллел хоёртын хайлтын нэг давталтад $x$-ээр $n$-ээс $1$-рүү гүйх замдаа дээр дурдсан $a_j \ge x$ бол 1 ээр үгүй бол -1 ээр тооцно гэдгээ одоо нэг segment tree-д https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A бодлогыг боддог шиг хадгалж яваад, хэрэв $i$-ийн хувьд $mid=x$ байдаг бол $i$-ийнхээ баруун зүүн талд нь segment tree-ийн 2 query хийхэд хангалттай.

**Time complexity: $O(n\log^2{n})$**\
[Submission](https://codeforces.com/contest/2126/submission/329505769)
